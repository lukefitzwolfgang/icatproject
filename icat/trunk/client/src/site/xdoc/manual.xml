<?xml version="1.0" encoding="UTF-8"?>
<document xmlns="http://maven.apache.org/XDOC/2.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/XDOC/2.0 http://maven.apache.org/xsd/xdoc-2.0.xsd">

    <properties>
        <title>ICAT Java Client User Manual</title>
    </properties>

    <body>

        <section name="Introduction">


            <p>The ICAT4 API is a layer on top of a relational DBMS.
                The database is wrapped as a web service so that the tables are
                not
                exposed
                directly. Each table in the database is mapped onto a
                data structure exposed by the web service. When the web service
                interface
                definition (WSDL) is processed for Java then each data
                structure results in a class definition.
            </p>

            <p>
                Please also consult the
                <a href="apidocs">javadoc.</a>

            </p>

            <p>
                Installation and accessing from maven is explained in
                <a href="installation.html">Java Client Installation.</a>
            </p>

            <subsection name="Setting Up">
                <p>The web service is accessed via a proxy (conventionally known as
                    a port). The proxy (here given a variable name of icat) may be
                    obtained by the following:
                </p>

                <code>
                    URL hostUrl = new URL("https://&lt;hostname&gt;:8181")
                    <br />
                    URL icatUrl = new URL(hostUrl, "ICATService/ICAT?wsdl");
                    <br />
                    QName qName = new
                    QName("http://icatproject.org", "ICATService");
                    <br />
                    ICATService service = new
                    ICATService(icatUrl, qName);
                    <br />
                    ICAT icat = service.getICATPort();
                </code>

                <p>where &lt;hostname&gt; should be the full name of the ICAT server. For a secure installation, just specifying localhost will not
                    work, the name must match what is on the host certificate.
                </p>

            </subsection>

            <subsection name="Session management">

                <p>When you login to ICAT you will be given back a string, the
                    sessionId, which must
                    be used as the first argument of almost all ICAT
                    calls.
                    The only
                    exceptions being the login call itself, getEntityInfo and getApiVersion - none of which require authentication.
                </p>

                <p class="call">String login(String plugin, Credentials credentials)</p>

                <p>
                    where the
                    <tt>plugin</tt>
                    is the mnemonic defined in the ICAT installation for the authentication plugin you wish to use and
                    <tt>credentials</tt>
                    is essentially a map. The names of the keys and their meaning is defined by the plugin.
                </p>

                <p>This sessionId returned will be valid for a period determined by the ICAT
                    server.
                </p>

                <p>The example below shows how it works for the authn_db plugin at the time of writing, where the plugin has been given the mnemonic
                    "db".
                </p>

                <code>
                    Credentials credentials = new Credentials();
                    <br />
                    List&lt;Entry&gt; entries = credentials.getEntry();
                    <br />
                    Entry e;
                    <br />
                    <br />
                    e = new Entry();
                    <br />
                    e.setKey("username");
                    <br />
                    e.setValue("root");
                    <br />
                    entries.add(e);
                    <br />

                    e = new Entry();
                    <br />
                    e.setKey("password");
                    <br />
                    e.setValue("secret");
                    <br />
                    entries.add(e);
                    <br />
                    <br />
                    String sessionId = icat.login("db", credentials);
                </code>

                <p class="call">double getRemainingMinutes(String sessionId)</p>

                <p>This returns the number of minutes left in the session. A
                    user may have more than one
                    session at
                    once.
                </p>

                <p class="call">String getUserName(String sessionId)</p>

                <p>This returns the string identifying the user of the session as provided by the authentication plugin.</p>

                <p class="call">void refresh(String sessionId)</p>
                <p>This resets the time-to-live of the session as it was when the session was first obtained.</p>

                <p class="call">void logout(String sessionId)</p>
                <p>This invalidates the sessionId.</p>

            </subsection>

            <subsection name="Exceptions">
                <p>There is only one exception thrown by ICAT. This is the IcatException_Exception
                    which is a wrapper around the real exception which
                    in turn includes an enumerated code to identify the kind of exception and the usual message. The codes and their meanings are:
                </p>

                <dl>
                    <dt>BAD_PARAMETER</dt>
                    <dd>generally indicates a problem with the arguments made to a call.</dd>
                    <dt>INTERNAL</dt>
                    <dd>may be caused by network problems, database problems, glassfish problems or bugs in ICAT.</dd>
                    <dt>INSUFFICIENT_PRIVILEGES</dt>
                    <dd>indicates that the authorization rules have not matched your request.</dd>
                    <dt>NO_SUCH_OBJECT_FOUND</dt>
                    <dd>is thrown when something is not found.</dd>
                    <dt>OBJECT_ALREADY_EXISTS</dt>
                    <dd>is thrown when type to create something but there is already one with the same values of the constraint fields.</dd>
                    <dt>SESSION</dt>
                    <dd>is used when the sessionId you have passed into a call is not valid or if you are unable to authenticate.</dd>
                    <dt>VALIDATION</dt>
                    <dd>marks an exception which was thrown instead of placing the database in an invalid state.</dd>

                </dl>

                <p>For
                    example to print what has happened
                    you might use the following:
                </p>
                <code>
                    String sessionId;
                    <br />
                    try {
                    <br />
                    &#160;&#160;&#160;sessionId = icat.login("db", credentials);
                    <br />
                    } catch (IcatException_Exception e) {
                    <br />
                    &#160;&#160;&#160;IcatException ue = e.getFaultInfo();
                    <br />
                    &#160;&#160;&#160;System.out.println("IcatException " + ue.getType() + " " + ue.getMessage()
                    <br />
                    &#160;&#160;&#160; + (ue.getOffset() >= 0 ? " at offset " + ue.getOffset() : ""));
                    <br />
                    }
                </code>
                <p>Operations which work on a list of objects, such as createMany, may fail because of failure to process one of the objects.
                    In this
                    case the state of the database will be rolled back and the offset within the list of the entry causing the error will be
                    stored in
                    the
                    IcatException. For
                    other
                    calls the offset will be negative, as it is with certain internal exceptions which are not
                    associated
                    with
                    any specific object
                    in a
                    list.
                </p>
            </subsection>

        </section>

        <section name="Data Manipulation">
            <subsection name="The schema">
                <p>
                    To understand exactly how the data manipulation calls work
                    requires an understanding of the
                    <a href="../icat.core/schema.html" target="_blank">schema.</a>
                    Please take a look now to make sense of the following explanation.
                </p>
                <p>
                    Each table in the database, representing a set of entities, is mapped onto a class in the API so terminology mixes OO and database
                    concepts. Each class has uniqueness constraints, relationships and other fields. Each object is identified by a field "id" which
                    is
                    managed by ICAT and is returned when you create an object. This is common to all objects and is not described in the schema. The
                    "id" field is used as the primary key in the database. There will normally be some combinations of fields, some of which may be
                    relationships, which must be unique across all entries in the table. This is marked as "Uniqueness constraint". For Dataset
                    this is
                    <tt>investigation, name</tt>
                    where
                    <tt>name</tt>
                    represents a relationship. No more than one one Dataset may exist with those two fields having the same
                    value. These constraints
                    are enforced by ICAT.
                </p>
                <p>The relationship table is shown next. The first column shows the minimum and maximum cardinality of the relationships. A Dataset
                    may be
                    related to any number of OutputDatasets, to at most one investigation and to exactly one DatasetType. The next column shows
                    the name
                    of the related class and this is followed by the name of the field which is used to represent the relationship. The basic
                    field name
                    is normally the name of the related class unless it is ambiguous or unnecessarily long. The field name is in the plural
                    for "to many"
                    relationships.
                    The next column, "cascaded", is marked yes to show that create and delete operations are cascaded.
                    If
                    a
                    Dataset is
                    deleted then all its DataCollectionDatasets, DatasetParameters and Datafiles are deleted at the same time by
                    one
                    call to
                    ICAT.
                    In a similar manner a tree, created in memory with a Dataset having a a set of Datafiles and Datasetparameters,
                    can be
                    persisted to
                    ICAT in a single call. This will be explained more later.
                </p>
                <p>Note that all "one to many" relationships are cascaded but no "many to one" relationships.
                </p>
                <p>Note also that all relationships are navigable in both directions.</p>
            </subsection>

            <subsection name="Creating an Object">
                <p class="call">long create(String sessionId, EntityBaseBean bean)
                </p>
                <p>To create an object in ICAT, first instantiate the object of
                    interest, for example a Dataset, and then call the setters to set its
                    attributes and finally make a call to create the object in ICAT.
                </p>
                <p>So typical code in Java might look like:</p>
                <code>
                    Dataset ds = new Dataset();
                    <br />
                    ds.setName("Name of dataset");
                    <br />
                    ds.set ...
                    <br />
                    Long dsid = icat.create(sessionId, ds);
                </code>
                <p>You will see that no convenient constructors are generated,
                    rather each field of the object must be set individually. Most
                    fields are
                    optional and may be left with null values, however some
                    are compulsory and the call to create will fail if they are not
                    set. Each
                    object has a primary key that identifies it in the
                    database - this is a value of type "long" that is generated
                    by ICAT and
                    is used to
                    represent relationships in a regular manner.
                </p>
                <p>
                    Some fields represent attributes of the object but others are
                    used to represent relationships. The relationships are
                    represented in
                    the class definitions by a variable which either
                    holds a reference to a single object or a list of objects. In the case of a list
                    it may be "cascaded".
                    Consider creating an Dataset with a set of Datafiles. Because the relationship from Dataset to Datafile is
                    cascaded they may be created in one call as
                    outlined below:
                </p>
                <code>
                    Dataset ds = new Dataset();
                    <br />
                    ds.setName(dsName);
                    <br />
                    ds.setType(type);
                    <br />
                    Datafile datafile = new Datafile();
                    <br />
                    datafile.setDatafileFormat(format);
                    <br />
                    datafile.setName(dfName);
                    <br />
                    ds.getDatafiles().add(datafile); // Add the datafile to the dataset
                    <br />
                    icat.create(sessionId, ds);
                </code>

                <p>The call to create returns the key of the created object. If you
                    choose to write:
                </p>

                <code>ds.setId(icat.create(sessionId, ds));</code>

                <p>then the client copy of the Dataset will be updated to have the
                    correct key value - however the keys in any other objects "within"
                    the Dataset will still be
                    null on the client side. In this case datafile.getId() will remain null.
                </p>

                <p>
                    When creating multiple objects in one call, the value of the cascaded flag must be noted. The line
                    <tt>ds.getDatafiles().add(datafile)</tt>
                    requires that the datafile is not already known to ICAT because the cascade flag is set. If the cascaded flag is set then objects
                    to be included in the "create" operation must not exist. However if the cascaded flag is not set then objects which are being
                    referenced must already exist in ICAT.
                </p>

                <p>
                    We now have an example of adding a datafile to an existing dataset,
                    <tt>ds</tt>
                </p>
                <code>
                    Datafile datafile = new Datafile();
                    <br />
                    datafile.setDatafileFormat(format);
                    <br />
                    datafile.setName(name);
                    <br />
                    datafile.setDataset(ds); // Relate the datafile to an existing dataset
                    <br />
                    datafile.setId(icat.create(sessionId, datafile)); // Create datafile and store id on client side
                </code>

                <p class="call">
                    List
                    &lt;Long&gt;
                    createMany(String sessionId, List
                    &lt;EntityBaseBean&gt;
                    beans)
                </p>

                <p>This call, as its name suggests, creates many objects. It takes the list of objects to create and returns a list of
                    ids. If any of
                    the individual operations fail the whole call fails and the database will be unchanged. The objects to
                    be created need not be of
                    the same type. For an example (where they are of the same type) consider adding many Datafiles
                    to a existing Dataset, ds:
                </p>
                <code>
                    List &lt;Datafile&gt; dfs = new ArrayList&lt;Datafile&gt;();
                    <br />
                    for (int i = 0; i &lt; n; i++) {
                    <br />
                    &#160;&#160;&#160;final
                    Datafile datafile = new Datafile();
                    <br />
                    &#160;&#160;&#160;datafile.setDatafileFormat(dfmt);
                    <br />
                    &#160;&#160;&#160;datafile.setName("bill"
                    + i);
                    <br />
                    &#160;&#160;&#160;datafile.setDataset(ds);
                    <br />
                    &#160;&#160;&#160;dfs.add(datafile);
                    <br />
                    }
                    <br />
                    icat.createMany(sesionId, dfs); // many datafiles are stored in one call
                    <br />
                </code>

            </subsection>
            <subsection name="Retrieving an object when you know its id">
                <p>There are alternative syntaxes for the query, the concise syntax and the JPQL inspired syntax</p>
                <h4>Concise syntax</h4>
                <p class="call">EntityBaseBean get(String sessionId, String query, long id)
                </p>
                <p>If dsid is the id of a Dataset then it may be retrieved by the call:</p>

                <code>Dataset ds = (Dataset) icat.get(sessionId, "Dataset", dsid);</code>

                <p id="get">
                    The second parameter is a string holding the name of the type of object to retrieve and some other optional information.
                    <em>By
                        default only the
                        requested object is returned and no related objects.
                    </em>
                    If you want the Dataset along with its related Datafiles,
                    DatasetParameters
                    and DatafileParameters then replace:
                    <tt>"Dataset"</tt>
                    with
                    <tt>"Dataset INCLUDE Datafile,DatasetParameter,DatafileParameter"</tt>
                </p>
                <p>
                    The related types must be all be related to the original type or to some other type in the list. This means that you could not
                    have
                    <tt>"Dataset INCLUDE DatafileParameter"</tt>
                    . There must be
                    only one route
                    from the original type to each of the included types.
                </p>
                <h4>JPQL inspired syntax</h4>
                <p>This syntax is only relevant if you have an INCLUDE clause as it allows more flexibility in specifying exactly what you want to get
                    back. The previous query to get a Dataset with all its Datafiles, DatasetParameters and DatafileParameters becomes:
                </p>
                <code>Dataset ds INCLUDE ds.datafiles.parameters, ds.parameters</code>
                <p>
                    Note that the variable "ds" has been introduced and is then used in the INCLUDE clause. This form of the INCLUDE clause is
                    explained in more
                    <a href="#newinclude">detail</a>
                    later
                </p>
            </subsection>

            <subsection name="Updating an Object">
                <p class="call">void update(String sessionId, EntityBaseBean bean)</p>
                <p>To update an object simply update the fields you want to change and call update. For example:</p>
                <code>
                    Dataset ds = (Dataset) icat.get(sessionId, "Dataset INCLUDE 1", dsid);
                    <br />
                    ds.setInvestigation(anotherInvestigation);
                    <br />
                    icat.update(sessionId, ds);
                </code>
                <p>
                    As suggested by the example
                    above
                    "many to one" relationships, such as the investigation relationship to the dataset, will be
                    updated as will any simple field
                    values. Consequently it is essential to get the existing values for any "many to one"
                    relationships. This is most reliably
                    achieved by the notation
                    <tt>INCLUDE 1</tt>
                    as shown here. The effect of the "1" is to include all "many to one" related types. "One to many" relationships are ignored by the
                    update mechanism so you need to start at the correct
                    end of the
                    relationship to have the desired effect.
                </p>
            </subsection>

            <subsection name="Deleting an Object">
                <p class="call">void delete(String sessionId, EntityBaseBean bean)</p>
                <p>The following code will get a dataset and delete it.</p>
                <code>
                    Dataset ds = (Dataset) icat.get(sessionId, "Dataset", dsid);
                    <br />
                    icat.delete(sessionId, ds);
                </code>

                <p>
                    All cascaded "one to many" related objects will also be deleted. In the extreme case, if you delete a facility, you lose
                    everything
                    associated with that facility. This privilege should not be given to many - see the
                    <a href="#authorization">authorization</a>
                    section later.
                </p>
            </subsection>

            <subsection name="Searching for an Object">
                <p>One call supports two alternative query syntaxes that can be used - concise or JPQL. The concise syntax is convenient if it does
                    what you
                    want, otherwise you have the full power of JPQL queries to use. In addition there is a free text search mechanism.
                </p>
                <h4>Concise syntax</h4>
                <p class="call">List&lt;Object&gt; search(String sessionId, String query)
                </p>
                <p>The concise syntax will be introduced by means of examples:</p>
                <code>List&lt;Object&gt; results = icat.search(sessionId, "Dataset");</code>

                <p>will return all Datasets. If the query is:</p>
                <code>"Dataset.name"</code>

                <p>this will return all Dataset names. Multiple datasets with the same name are permitted and this call will include duplicates.
                    Instead
                </p>

                <code>"DISTINCT Dataset.name"</code>

                <p>
                    will avoid duplicates. To get related objects returned, then the same INCLUDE syntax that was described for the
                    <a href="#get">get</a>
                    call may be used with exactly the same restrictions and semantics:
                </p>

                <code>"Dataset INCLUDE Datafile,DatasetParameter,DatafileParameter"</code>

                <p>You can specify an order (which may precede or follow an INCLUDE clause):</p>

                <code>"Dataset.id ORDER BY id"</code>

                <p>Restrictions can be placed on the data returned. For example:</p>
                <code>"Dataset.id [type.name IN ('GS', 'GQ')]"</code>
                <p>which could also be written:</p>
                <code>"Dataset.id [type.name = 'GS' OR type.name = 'GQ']"</code>
                <p>The restriction in the square brackets can be as complex as required - but must only refer to attributes of the object being
                    restricted - in this case the Dataset. Expressions may use parentheses, AND, OR, &lt;, &lt;=, &gt;, &gt;=, =, &lt;&gt;, !=, NOT,
                    IN, LIKE and
                    BETWEEN. Currently the BETWEEN operator does not work on strings. This appears to be a JPA bug.
                </p>
                <p>Functions: MAX, MIN, COUNT, AVG and SUM may also be used such as:</p>
                <code>"MAX (Dataset.id)"</code>
                <p>Selection may involve more than one related object. To show the relationship a "&lt;-&gt;" token is used. For example:</p>
                <code>"Dataset.id &lt;-&gt;
                    DatasetParameter[type.name = 'TIMESTAMP']"
                </code>
                <p>
                    Note also here the use of the JPQL style path:
                    <tt>type.name</tt>
                    .
                    This expressions means ids of Datasets which have a
                    DatasetParameter which has a type with a name of TIMESTAMP. Multiple
                    "
                    <tt>&lt;-&gt;"</tt>
                    may appear but all the objects involved,
                    including the first one, must be connectable in only one way.
                </p>
                <p>It is also possible to restrict the number of results returned by specifying a pair of numbers at the beginning of the query
                    string. This construct would normally be used with an ORDER BY clause. The first number is the offset from within the full list of
                    available results from which to start returning data and the second is the maximum number of results to return. These numbers if
                    specified must be positive. If the offset is greater than or equal to the number of internal results then no data will be
                    returned. The default values are 0 and "infinity". The numbers must be separated by a comma though either may be omitted. The
                    following are all valid. The last example is rather pointless and does the same as the first. A number without a comma is illegal.
                </p>
                <code>
                    "&#160;&#160;&#160;&#160;Dataset.id ORDER BY id"
                    <br />
                    "3,5&#160;Dataset.id ORDER BY id"
                    <br />
                    "3,&#160;&#160;Dataset.id ORDER BY id"
                    <br />
                    "&#160;,5&#160;Dataset.id ORDER BY id"
                    <br />
                    "&#160;,&#160;&#160;Dataset.id ORDER BY id"
                </code>

                <h4>JPQL syntax</h4>
                <p>
                    This is simply JPQL including the SELECT keyword.
                    For example the concise query "Dataset" in the call
                    <tt>List&lt;Object&gt; results = icat.search(sessionId, "Dataset")</tt>
                    can be replaced by:
                </p>
                <code>
                    SELECT ds.id
                    <br />
                    FROM Dataset ds
                </code>
                <p>
                    and the concise query
                    <tt>Dataset.id &lt;-&gt; DatasetParameter[type.name = 'TIMESTAMP']</tt>
                    becomes:
                </p>

                <code>
                    SELECT ds.id
                    <br />
                    FROM Dataset ds JOIN ds.parameters p
                    <br />
                    WHERE p.type.name = 'TIMESTAMP'
                </code>

                <p>The only restriction is that the returned item must be a set of entities, the result of an aggregate function (such as COUNT
                    or
                    MAX)
                    or a set of values of one field of an entity type. Currently nested selects are not supported - but when they are supported please
                    define new variables for use within such a construct.
                </p>

                <p>

                    There are also two extensions to JPQL a LIMIT clause and an INCLUDE clause which may come in either order after the standard
                    JPQL.
                    The LIMIT clase follows MySQL syntax and takes the form:
                    <code>LIMIT 10, 100</code>
                    which will skip 10 results and return the next 100. A LIMIT clause will normally be used with an ORDER BY clause.

                    <h5>
                        JQPL Inspired INCLUDE syntax
                        <a name="newinclude" />
                    </h5>
                    An example of an
                    INCLUDE clause is:
                </p>

                <code>
                    SELECT ds
                    <br />
                    FROM Dataset ds
                    <br />
                    INCLUDE ds.datafiles.parameters, ds.parameters
                </code>
                <p>
                    This uses the variable "ds" defined in the FROM clause. It means that the "Dataset" field "datafiles"
                    will be followed to include
                    all those "Datafiles" and that for each "Datafile" the "parameters" field
                    will be followed to get the "DatafileParameters". In
                    addition the "DatasetParameters" will be included. Those entities which the user is not allowed to read are silently ignored. The
                    above INCLUDE clause could also be written:
                </p>
                <code>

                    INCLUDE ds.datafiles AS dsp, dsp.parameters, ds.parameters
                </code>
                <p>This introduces a new variable dsp which is used later in the clause. The keyword "AS" is optional.</p>
                <p>The variables defined outside the INCLUDE clause are not available inside the INCLUDE clause except for the variable identifying
                    the main object being returned. In this case the pre-defined variable is "ds".
                </p>
                <p>It is permissible to visit an entity type more than once in an INCLUDE - for example following a provenance chain.</p>

                <h4>Free text syntax</h4>
                <p class="call">List&lt;Object&gt; search(String sessionId, String query, int maxCount, String entityName)
                </p>
                <p>This treats each ICAT entry as a document. The contents of that document is formed by concatenating all the non-blank text
                    fields
                    (with a space bewteen them). These documents are then indexed by Lucene. Each create, update or delete call updates the set of
                    available "documents". The indices are updated periodically - so new entries will not be immediately visible. The freshness of the
                    data is determined by the ICAT configuration and may be adjusted. As with the other search call you will only see the data you are
                    allowed to see by the authorization rules. Please see the following examples.
                </p>
                <code>List&lt;Object&gt; results = icat.searchText(sessionId, "king", 50, null);</code>
                <p>This obtains the 50 "best" documents with the work "king" in them.</p>

                <code>List&lt;Object&gt; results = icat.searchText(sessionId, "king queen", 50, null);</code>
                <p>returns documents with "king" or "queen" in them.</p>

                <code>List&lt;Object&gt; results = icat.searchText(sessionId, "king AND (queen OR harp", 50, null);</code>
                <p>returns documents with "king" and either "queen" or "harp".</p>

                <p>Case is ignored and there is no need to put in words with different endings but the same stem as common suffices are removed
                    both
                    when storing the document indices and when looking them up. Wild cards may be used - the ? for a single character and * for zero
                    or
                    more. The last argument my be the simple name of an entity as shown below.
                </p>

                <code>List&lt;Object&gt; results = icat.searchText(sessionId, "king", 50, "Investigation");</code>
                <p>This restricts the search to the "Investigation" set of entities.</p>

            </subsection>

        </section>

        <section name="Authorization">
            <p>
                <a name="authorization" />
                The mechanism is rule based. Rules allow groupings of
                users to do things. There are four things that can be
                done: Create, Read, Update
                and
                Delete. It makes use of
                five tables: Rule, User, Grouping, UserGroup and PublicStep. The name "Grouping" has been introduced as
                "Group" is a reserved word in JPQL. The
                authentication mechanism authenticates a person with a
                certain
                name and this name identifies the
                User in the
                ICAT User table. Groupings have names and the UserGroup
                performs the function of a "many to
                many" relationship
                between Users
                and Groupings. Rules are applied to Groupings.
                There are special "root users" able to manipulate these
                four
                tables, but only these five
                unless a "root user" creates
                rules to give himself further powers. Apart from the
                special role of "root
                users" these tables
                behave as
                other
                ICAT tables do. The set of "root users" is a configuration parameter of the ICAT installation.
            </p>
            <subsection name="Rules" id="rules">
                <p>
                    By default access is denied to all objects, rules allow access. It is only necessary to be permitted by one rule
                    where that rule is
                    only applied to the object referenced directly in the API call. The Rule table has two exposed fields:
                    <tt>crudFlags</tt>
                    and
                    <tt>what</tt>
                    .

                    The field
                    <tt>crudFlags</tt>
                    contains letters from the set "CRUD" to indicate which types of operation are being allowed (Create, Read, Update and/or Delete).
                    The other field,
                    <tt>what</tt>
                    , is the rule itself. There is also a "many to one" relationship to Group which may be absent.
                </p>
                <p>Consider:</p>
                <code>
                    Rule rule = new Rule();
                    <br />
                    rule.setGroup(userOffice);
                    <br />
                    rule.setCrudFlags("CRUD");
                    <br />
                    rule.setWhat("Investigation");
                    <br />
                    icat.create(sessionId, rule);
                </code>
                <p>allows members of the userOffice group full access to all Investigations. Note that the id field of the rule on the client side
                    is
                    not set on the assumption that the client side copy of the rule will not be needed further.
                </p>
                <code>
                    Rule rule = new Rule();
                    <br />
                    rule.setGroup(null); // Not necessary as it will be null on a newly created rule
                    <br />
                    rule.setCrudFlags("R");
                    <br />
                    rule.setWhat("ParameterType");
                    <br />
                    icat.create(sessionId, rule);
                </code>
                <p>allows any authenticated user (with a sessionId) to read Parameters. Consider a group of users: fredReaders.
                    To allow fredReaders to
                    read a datafile with a name of "fred" we could have:
                </p>
                <code>
                    Rule rule = new Rule();
                    <br />
                    rule.setGroup(fredReaders);
                    <br />
                    rule.setCrudFlags("R");
                    <br />
                    rule.setWhat("Datafile [name='fred']");
                    <br />
                    icat.create(sessionId, rule);
                </code>
                <p>More complex restrictions can be added using other related objects. For example to allow read access to Datasets belonging to an
                    Investigation which includes an InvestigationUser which has a user with a name matching the currently authenticated user (from the
                    sessionId) we can have:
                </p>
                <code>
                    Rule rule = new Rule();
                    <br />
                    rule.setGroup(null);
                    <br />
                    rule.setCrudFlags("R");
                    <br />
                    rule.setWhat("Dataset &lt;-&gt; Investigation &lt;-&gt; InvestigationUser &lt;-&gt; User[name = :user]");
                    <br />
                    icat.create(sessionId, rule);
                </code>
                <p>
                    where the
                    <tt>:user</tt>
                    denotes the currently authenticated user (derived from the
                    sessionId). You will note that the syntax is very similar to that
                    used by
                    the search except that INCLUDE, LIMIT and ORDER BY clauses may not be used. The syntax of the "What" may be either the old concise
                    syntax or the new JPQL syntax.
                </p>
                <p>There is currently an important restriction to avoid a problem which has occured in testing: with
                    the JPQL syntax only one dot may
                    appear for terms in the WHERE clause and for the old syntax no dots are allowed in the condition
                    in square brackets. You will get
                    an error message if you forget.
                </p>

                <p>Rules which allow every one to read a table are good for performance. For example:</p>
                <code>
                    Rule rule = new Rule();
                    <br />
                    rule.setGroup(null);
                    <br />
                    rule.setCrudFlags("R");
                    <br />
                    rule.setWhat("DatasetType");
                    <br />
                    icat.create(sessionId, rule);
                </code>
                <p>Such rules are also cached in memory.</p>

                <h4>PublicStep</h4>
                <p>This table has two columns (origin and field). An entry in this table affects the way in which INCLUDE authorizationis carried out.
                    Each entry permits all users to make a step from the origin entity by the specifed relationship field without any further
                    checking. This
                    information is held in memory for speed.
                </p>

            </subsection>
            <subsection name="Checking accessibility">
                <p class="call">boolean isAccessAllowed(String sessionId, EntityBaseBean bean, AccessType accessType)</p>
                <p>This call returns true if the access to the bean specified by the accessType is permitted. For example:
                </p>
                <code>
                    Dataset ds = new Dataset();
                    <br />
                    ds.setName("Name of dataset");
                    <br />
                    ds.set ...
                    <br />
                    System.out.println(isAccessAllowed(sessionId, ds, AccessType.CREATE))
                </code>
                <p>This code sets up a Dataset and then prints whether or not it would be allowed to create it.</p>
                <p>This call is expected to be made from GUIs so that they can avoid offering operations that will fail. As such, though
                    READ acess may
                    be queried it is unlikely to be useful as the GUI user will not have found out about the object to be
                    checked. If READ, DELETE or
                    UPDATE access is queried for an object that does not exist it will return false.
                </p>
                <p>
                    In the case of
                    CREATE, the entity is created
                    within a database transaction, the check is made and the transaction is rolled back. Do
                    not populate
                    any one-to-many collections
                    for the entity being tested - this will cause an exception to be raised. Also note that if
                    a
                    <tt>create</tt>
                    operation would result in a duplicate this may cause an exception to be thrown but this cannot be relied upon.
                </p>
            </subsection>
        </section>
        <section name="Logging">
            <p>Logging to a table with the entity name Log (and/or a file in the logs directory) may be enabled in the icat.properties file of the
                ICAT server. Records of the type requested in the
                icat.properites file are added to this table for each eligible call. The information
                in the table may be regarded as sensitive so appropriate authorization rules should be created.
            </p>
        </section>
        <section name="Notifications">
            <p>
                ICAT is able to send JMS messages for create, update and delete of sslected entities. This is controlled by the icat.properties file
                of the ICAT server which can specify a list of the entity types to consider, and for each type which action to generate a message for.
                The JMS message is always PubSub rather than point to point. This means that there can be multiple listeners for a message.

                Any
                receiver must be set up to receive messages with a topic of "jms/ICAT/Topic". The messages all have properties of "entity" which is
                the
                type of the
                entity such as
                <tt>Dataset</tt>
                and "operation" which is one of the letters: C, U and D (for create, update and delete respectively). The body of the message is an
                object which holds the entity id as a Long. For the "xxxMany" calls multiple notifications will be generated. A receiver typically
                implemented as an MDB (Message Driven Bean) should filter the messages it processes by using the properties of the message.

            </p>

            <p>It should be noted that by the time you can react to a deletion notification the entity id you are sent will refer to an object which
                no longer exists.
            </p>

            <p>This mechanism does not leak information becuase all the user receives is an entity id. To read the entity with that id the user must
                have read access to that entity instance.
            </p>

            <p>
                There is an
                <a href="http://code.google.com/p/icatproject/source/browse/contrib/notification-receiver-example">example MDB</a>
                available which should make this easier to understand.
            </p>


        </section>

        <section name="Information">
            <p class="call">String getApiVersion()</p>

            <p>returns the version of the API - this should match the
                version of the client as it is held in Maven for a
                released component. In the case
                of a release candidate
                such as 4.2.0-rc03 the version returned will still be
                4.2.0 .
            </p>

            <p class="call"> List&lt;String&gt; getEntityNames()</p>

            <p>Returns an alphabetic list of all the entity names known to ICAT. This is of most value for tools.</p>

            <p class="call"> EntityInfo getEntityInfo(String beanName)</p>


            <p>returns full information about a table given its name. For example:</p>
            <code>
                EntityInfo ei = icat.getEntityInfo("Investigation");
                <br />
                System.out.println(ei.getClassComment());
                <br />
                for (Constraint c : ei.getConstraints()) {
                <br />
                &#160;&#160;&#160;System.out.println("Constraint columns: " + c.getFieldNames());
                <br />
                }
                <br />
                for (EntityField f : ei.getFields()) {
                <br />
                &#160;&#160;&#160;System.out.println("Field names: " + f.getName());
                <br />
                }
                <br />
            </code>
            <p>
                Prints out some information about the Investigation table. For a list of all available fields in EntityInfo and the objects it
                references please
                consult the
                <a href="apidocs/org/icatproject/EntityInfo.html">javadoc for EntityInfo</a>
                .
            </p>


        </section>
    </body>

</document>
