<?xml version="1.0" encoding="UTF-8"?>
<document xmlns="http://maven.apache.org/XDOC/2.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/XDOC/2.0 http://maven.apache.org/xsd/xdoc-2.0.xsd">

    <properties>
        <title>ICAT Java Client User Manual</title>
    </properties>

    <body>

        <section name="Introduction">


            <p>The ICAT4 API is a layer on top of a relational DBMS.
                The database is wrapped as a web service so that the tables are
                not
                exposed
                directly. Each table in the database is mapped onto a
                data structure exposed by the web service. When the web service
                interface
                definition (WSDL) is processed for Java then each data
                structure results in a class definition.
            </p>

            <p>
                Please also consult the
                <a href="apidocs">javadoc.</a>

            </p>

            <p>
                Installation and accessing from maven is explained in
                <a href="installation.html">Java Client Installation.</a>
            </p>

            <subsection name="Setting Up">
                <p>The web service is accessed via a proxy (conventionally known as
                    a port). The proxy (here given a variable name of icat) may be
                    obtained by the following:
                </p>

                <code>
                    URL hostUrl = new URL("https://&lt;hostname&gt;:8181")
                    <br />
                    URL icatUrl = new URL(hostUrl, "ICATService/ICAT?wsdl");
                    <br />
                    QName qName = new
                    QName("http://icatproject.org", "ICATService");
                    <br />
                    ICATService service = new
                    ICATService(icatUrl, qName);
                    <br />
                    ICAT icat = service.getICATPort();
                </code>

                <p>where &lt;hostname&gt; should be the full name of the ICAT server. For a secure installation, just specifying localhost will not
                    work, the name must match what is on the host certificate.
                </p>

            </subsection>

            <subsection name="Session management">

                <p>When you login to ICAT you will be given back a string, the
                    sessionId, which must
                    be used as the first argument of almost all ICAT
                    calls.
                    The only
                    exceptions being the login call itself, getEntityInfo and getApiVersion - none of which require authentication.
                </p>

                <p class="call">String login(String plugin, Credentials credentials)</p>

                <p>
                    where the
                    <tt>plugin</tt>
                    is the mnemonic defined in the ICAT installation for the authentication plugin you wish to use and
                    <tt>credentials</tt>
                    is essentially a map. The names of the keys and their meaning is defined by the plugin.
                </p>

                <p>This sessionId returned will be valid for a period determined by the ICAT
                    server.
                </p>

                <p>The example below shows how it works for the authn_db plugin at the time of writing, where the plugin has been given the mnemonic
                    "db".
                </p>

                <code>
                    Credentials credentials = new Credentials();
                    <br />
                    List&lt;Entry&gt; entries = credentials.getEntry();
                    <br />
                    Entry e;
                    <br />
                    <br />
                    e = new Entry();
                    <br />
                    e.setKey("username");
                    <br />
                    e.setValue("root");
                    <br />
                    entries.add(e);
                    <br />

                    e = new Entry();
                    <br />
                    e.setKey("password");
                    <br />
                    e.setValue("secret");
                    <br />
                    entries.add(e);
                    <br />
                    <br />
                    String sessionId = icat.login("db", credentials);
                </code>



                <p class="call">double getRemainingMinutes(String sessionId)</p>

                <p>This returns the number of minutes left in the session. A
                    session
                    may not be extended but a user may have more than one
                    session at
                    once.
                </p>

                <p class="call">void refresh(String sessionId)</p>
                <p>This resets the time to live of the session as it was when the session was first obtained.</p>

                <p class="call">void logout(String sessionId)</p>
                <p>This invalidates the sessionId.</p>

            </subsection>

            <subsection name="Exceptions">
                <p>There is only one exception thrown by ICAT. This is the IcatException_Exception
                    which is a wrapper around the real exception which
                    in turn includes an enumerated code to identify the kind of exception and the usual message. The codes and their meanings are:
                </p>

                <dl>
                    <dt>BAD_PARAMETER</dt>
                    <dd>generally indicates a problem with the arguments made to a call.</dd>
                    <dt>INTERNAL</dt>
                    <dd>may be caused by network problems, database problems, glassfish problems or bugs in ICAT.</dd>
                    <dt>INSUFFICIENT_PRIVILEGES</dt>
                    <dd>indicates that the authorization rules have not matched your request.</dd>
                    <dt>NO_SUCH_OBJECT_FOUND</dt>
                    <dd>is thrown when something is not found.</dd>
                    <dt>OBJECT_ALREADY_EXISTS</dt>
                    <dd>is thrown when type to create something but there is already one with the same values of the constraint fields.</dd>
                    <dt>SESSION</dt>
                    <dd>is used when the sessionId you have passed into a call is not valid or if you are unable to authenticate.</dd>
                    <dt>VALIDATION</dt>
                    <dd>marks an exception which was thrown instead of placing the database in an invalid state.</dd>

                </dl>

                <p>For
                    example to print what has happened
                    you might use the following:
                </p>
                <code>
                    String sessionId;
                    <br />
                    try {
                    <br />
                    &#160;&#160;&#160;sessionId = icat.login("db", credentials);
                    <br />
                    } catch (IcatException_Exception e) {
                    <br />
                    &#160;&#160;&#160;IcatException ue = e.getFaultInfo();
                    <br />
                    &#160;&#160;&#160;System.out.println("IcatException " + ue.getType() + " " + ue.getMessage()
                    <br />
                    &#160;&#160;&#160; + (ue.getOffset() >= 0 ? " at offset " + ue.getOffset() : ""));
                    <br />
                    }
                </code>
                <p>Operations which work on a list of objects, such as createMany, may fail because of failure to process one of the objects.
                    In this
                    case the state of the database will be rolled back and the offset within the list of the entry causing the error will be
                    stored in
                    the
                    IcatException. For
                    other
                    calls the offset will be negative, as it is with certain internal exceptions which are not
                    associated
                    with
                    any specific object
                    in a
                    list.
                </p>
            </subsection>

        </section>

        <section name="Data Manipulation">
            <subsection name="The schema">
                <p>
                    To understand exactly how the data manipulation calls work
                    requires an understanding of the
                    <a href="../icat.core/schema.html" target="_blank">schema.</a>
                    Please take a look now to make sense of the following explanation.
                </p>
                <p>
                    Each table in the database, representing a set of entities, is mapped onto a class in the API so terminology mixes OO and database
                    concepts.
                    Each class has uniqueness constraints, relationships and other fields. Each object is identified by a field "id" which is
                    managed by ICAT and is returned when you create an object. This is common to all objects and is not described in the schema. The
                    "id"
                    field is used as the primary key in the database. There will normally be some combinations of fields, some of which may be
                    relationships, which must be unique across all entries in the table. This is marked as "Uniqueness constraint". For Dataset
                    this
                    is
                    <tt>sample, investigation, name, type</tt>
                    which, apart from
                    <tt>name,</tt>
                    are all relationships. No more than one one Dataset may exist with those four fields having the same
                    value. These constraints are
                    enforced by ICAT.
                </p>
                <p>The relationship table is shown next. The first column shows the minimum and maximum cardinality of the relationships. A Dataset
                    may be
                    related to any number of OutputDatasets, to at most one investigation and to exactly one DatasetType. The next column shows
                    the name
                    of the related class and this is followed by the name of the field which is used to represent the relationship. The basic
                    field name
                    is normally the name of the related class unless it is ambiguous or unnecessarily long. The field name is in the plural
                    for "to many"
                    relationships.
                    The next column, "cascaded", is marked yes to show that create and delete operations are cascaded.
                    If
                    a
                    Dataset is
                    deleted then all its OutputDatasets, DatasetParameters, Datafiles and InputDatasets are deleted at the same time by
                    one
                    call to ICAT.
                    In a similar manner a tree, created in memory with a Dataset having a a set of Datafiles and Datasetparameters,
                    can be
                    persisted to
                    ICAT in a single call. This will be explained more later.
                </p>
                <p>Note that currently all "one to many" relationships are cascaded but no "many to one" relationships. Do not assume that this will
                    always be true.
                </p>
                <p>Note also that all relationships are navigable in both directions.</p>
            </subsection>

            <subsection name="Creating an Object">
                <p class="call">long create(String sessionId, EntityBaseBean bean)
                </p>
                <p>To create an object in ICAT, first instantiate the object of
                    interest, for example a Dataset, and then call the setters to set its
                    attributes and finally make a call to create the object in ICAT.
                </p>
                <p>So typical code in Java might look like:</p>
                <code>
                    Dataset ds = new Dataset();
                    <br />
                    ds.setName("Name of dataset");
                    <br />
                    ds.set ...
                    <br />
                    Long dsid = icat.create(sessionId, ds);
                </code>
                <p>You will see that no convenient constructors are generated,
                    rather each field of the object must be set individually. Most
                    fields are
                    optional and may be left with null values, however some
                    are compulsory and the call to create will fail if they are not
                    set. Each
                    object has a primary key that identifies it in the
                    database - this is a value of type "long" that is generated
                    by ICAT and
                    is used to
                    represent relationships in a regular manner.
                </p>
                <p>
                    Some fields represent attributes of the object but others are
                    used to represent relationships. The relationships are
                    represented in
                    the class definitions by a variable which either
                    holds a reference to a single object or a list of objects. In the case of a list
                    it may be "cascaded".
                    Consider creating an Dataset with a set of Datafiles. Because the relationship from Dataset to Datafile is
                    cascaded they may be created in one call as
                    outlined below:
                </p>
                <code>
                    Dataset ds = new Dataset();
                    <br />
                    ds.setName(dsName);
                    <br />
                    ds.setType(type);
                    <br />
                    Datafile datafile = new Datafile();
                    <br />
                    datafile.setDatafileFormat(format);
                    <br />
                    datafile.setName(dfName);
                    <br />
                    ds.getDatafiles().add(datafile); // Add the datafile to the dataset
                    <br />
                    icat.create(sessionId, ds);
                </code>

                <p>The call to create returns the key of the created object. If you
                    choose to write:
                </p>

                <code>ds.setId(icat.create(sessionId, ds));</code>

                <p>then the client copy of the Dataset will be updated to have the
                    correct key value - however the keys in any other objects "within"
                    the Dataset will still be
                    null on the client side. In this case datafile.getId() will remain null.
                </p>

                <p>
                    When creating multiple objects in one call, the value of the cascaded flag must be noted. The line
                    <tt>ds.getDatafiles().add(datafile)</tt>
                    requires that the datafile is not already known to ICAT because the cascade flag is set. If the cascaded flag is set then objects
                    to be included in the "create" operation must not exist. However if the cascaded flag is not set then objects which are being
                    referenced must already exist in ICAT.
                </p>

                <p>
                    We now have an example of adding a datafile to an existing dataset,
                    <tt>ds</tt>
                </p>
                <code>
                    Datafile datafile = new Datafile();
                    <br />
                    datafile.setDatafileFormat(format);
                    <br />
                    datafile.setName(name);
                    <br />
                    datafile.setDataset(ds); // Relate the datafile to an existing dataset
                    <br />
                    datafile.setId(icat.create(sessionId, datafile)); // Create datafile and store id on client side
                </code>

                <p class="call">
                    List
                    &lt;Long&gt;
                    createMany(String sessionId, List
                    &lt;EntityBaseBean&gt;
                    beans)
                </p>

                <p>This call, as its name suggests, creates many objects. It takes the list of objects to create and returns a list of
                    ids. If any of
                    the individual operations fail the whole call fails and the database will be unchanged. The objects to
                    be created need not be of
                    the same type. For an example (where they are of the same type) consider adding many Datafiles
                    to a existing Dataset, ds:
                </p>
                <code>
                    List &lt;Datafile&gt; dfs = new ArrayList&lt;Datafile&gt;();
                    <br />
                    for (int i = 0; i &lt; n; i++) {
                    <br />
                    &#160;&#160;&#160;final
                    Datafile datafile = new Datafile();
                    <br />
                    &#160;&#160;&#160;datafile.setDatafileFormat(dfmt);
                    <br />
                    &#160;&#160;&#160;datafile.setName("bill"
                    + i);
                    <br />
                    &#160;&#160;&#160;datafile.setDataset(ds);
                    <br />
                    &#160;&#160;&#160;dfs.add(datafile);
                    <br />
                    }
                    <br />
                    icat.createMany(sesionId, dfs); // many datafiles are stored in one call
                    <br />
                </code>

            </subsection>
            <subsection name="Retrieving an object when you know its id">
                <p class="call">EntityBaseBean get(String sessionId, String query, long id)
                </p>
                <p>If dsid is the id of a Dataset then it may be retrieved by the call:</p>

                <code>Dataset ds = (Dataset) icat.get(sessionId, "Dataset", dsid);</code>

                <p id="get">
                    The second parameter is a string holding the name of the type of object to retrieve and some other optional information.
                    <em>By
                        default only the
                        requested object is returned and no related objects.
                    </em>
                    If you want the Dataset along with its related Datafiles,
                    DatasetParameters
                    and DatafileParameters then replace:
                    <tt>"Dataset"</tt>
                    with
                    <tt>"Dataset INCLUDE Datafile,DatasetParameter,DatafileParameter"</tt>
                </p>
                <p>
                    The related types must be all be related to the original type or to some other type in the list. This means that you could not
                    have
                    <tt>"Dataset INCLUDE DatafileParameter"</tt>
                    . Not all relationships can be followed, the rule appears complex but is there to support the
                    <a href="#authorization">authorization</a>
                    scheme which is
                    explained later.
                    Starting from the first type (before the INCLUDE keyword) cascaded "one to many" relationships
                    may
                    be followed
                    repeatedly. In addition "many to one" relationships can be followed. The idea behind this is that
                    cascaded "one to
                    many"
                    relationships represent composition/ownership - i.e. a dataset is made up of datafiles and the "many to one"
                    is allowed as
                    these
                    are
                    typically shared objects. This means that starting from a Dataset, one could follow the cascaded "one to
                    many"
                    relationships to
                    get
                    to Datafile, DatasetParameter and DatafileParameter. From this set of types (Dataset, Datafile,
                    DatasetParameter and
                    DatafileParameter) one can follow the "many to one" relationships to reach at most one of each of Facility,
                    Investigation,
                    InvestigationType, DatasetType, Instrument, FacilityCycle, ParameterType and DatafileFormat. Finally there must be
                    only one route
                    from the original type to each of the included types.
                </p>
            </subsection>

            <subsection name="Updating an Object">
                <p class="call">void update(String sessionId, EntityBaseBean bean)</p>
                <p>To update an object simply update the fields you want to change and call update. For example:</p>
                <code>
                    Dataset ds = (Dataset) icat.get(sessionId, "Dataset INCLUDE 1", dsid);
                    <br />
                    ds.setInvestigation(anotherInvestigation);
                    <br />
                    icat.update(sessionId, ds);
                </code>
                <p>
                    As suggested by the example
                    above
                    "many to one" relationships, such as the investigation relationship to the dataset, will be
                    updated as will any simple field
                    values. Consequently it is essential to get the existing values for any "many to one"
                    relationships. This is most reliably
                    achieved by the notation
                    <tt>INCLUDE 1</tt>
                    as shown here. The effect of the "1" is to include all "many to one" related types. "One to many" relationships are ignored by the
                    update mechanism so you need to start at the correct
                    end of the
                    relationship to have the desired effect.
                </p>
            </subsection>

            <subsection name="Deleting an Object">
                <p class="call">void delete(String sessionId, EntityBaseBean bean)</p>
                <p>The following code will get a dataset and delete it.</p>
                <code>
                    Dataset ds = (Dataset) icat.get(sessionId, "Dataset", dsid);
                    <br />
                    icat.delete(sessionId, ds);
                </code>

                <p>
                    All cascaded "one to many" related objects will also be deleted. In the extreme case, if you delete a facility, you lose
                    everything
                    associated with that facility. This privilege should not be given to many - see the
                    <a href="#authorization">authorization</a>
                    section later.
                </p>
            </subsection>

            <subsection name="Searching for an Object - Database related syntax">
                <p class="call">List&lt;Object&gt; search(String sessionId, String query)
                </p>
                <p>A rather powerful search mechanism is provided. It will be introduced by means of examples:</p>
                <code>List&lt;Object&gt; results = icat.search(sessionId, "Dataset");</code>

                <p>will return all Datasets. If the query is:</p>
                <code>"Dataset.name"</code>

                <p>this will return all Dataset names. Multiple datasets with the same name are permitted and this call will include duplicates.
                    Instead
                </p>

                <code>"DISTINCT Dataset.name"</code>

                <p>
                    will avoid duplicates. To get related objects returned, then the same INCLUDE syntax that was described for the
                    <a href="#get">get</a>
                    call may be used with exactly the same restrictions and semantics:
                </p>

                <code>"Dataset INCLUDE Datafile,DatasetParameter,DatafileParameter"</code>

                <p>You can specify an order (which may precede or follow an INCLUDE clause):</p>

                <code>"Dataset.id ORDER BY id"</code>

                <p>Restrictions can be placed on the data returned. For example:</p>
                <code>"Dataset.id [type.name IN ('GS', 'GQ')]"</code>
                <p>which could also be written:</p>
                <code>"Dataset.id [type.name = 'GS' OR type.name = 'GQ']"</code>
                <p>The restriction in the square brackets can be as complex as required - but must only refer to attributes of the object being
                    restricted - in this case the Dataset. Expressions may use parentheses, AND, OR, &lt;, &lt;=, &gt;, &gt;=, =, &lt;&gt;, !=, NOT,
                    IN, LIKE and
                    BETWEEN. Currently the BETWEEN operator does not work on strings. This appears to be a JPA bug.
                </p>
                <p>Functions: MAX, MIN, COUNT, AVG and SUM may also be used such as:</p>
                <code>"MAX (Dataset.id)"</code>
                <p>Selection may involve more than one related object. To show the relationship a "&lt;-&gt;" token is used. For example:</p>
                <code>"Dataset.id &lt;-&gt;
                    DatasetParameter[type.name = 'TIMESTAMP']"
                </code>
                <p>
                    Note also here the use of the JPQL style path:
                    <tt>type.name</tt>
                    .
                    This expressions means ids of Datasets which have a
                    DatasetParameter which has a type with a name of TIMESTAMP. Multiple
                    "
                    <tt>&lt;-&gt;"</tt>
                    may appear but all the objects involved,
                    including the first one, must be connectable in only one way.
                </p>
                <p>It is also possible to restrict the number of results returned by specifying a pair of numbers at the beginning of the query
                    string. This construct would normally be used with an ORDER BY clause. The first number is the offset from within the full list of
                    available results from which to start returning data and the second is the maximum number of results to return. These numbers if
                    specified must be positive. If the offset is greater than or equal to the number of internal results then no data will be
                    returned. The default values are 0 and "infinity". The numbers must be separated by a comma though either may be omitted. The
                    following are all valid. The last example is rather pointless and does the same as the first. A number without a comma is illegal.
                </p>
                <code>
                    "&#160;&#160;&#160;&#160;Dataset.id ORDER BY id"
                    <br />
                    "3,5&#160;Dataset.id ORDER BY id"
                    <br />
                    "3,&#160;&#160;Dataset.id ORDER BY id"
                    <br />
                    "&#160;,5&#160;Dataset.id ORDER BY id"
                    <br />
                    "&#160;,&#160;&#160;Dataset.id ORDER BY id"
                </code>
            </subsection>

            <subsection name="Searching for an Object - Free text syntax">
                <p class="call">List&lt;Object&gt; search(String sessionId, String query, int maxCount, String entityName)
                </p>
                <p>This treats each ICAT entry as a document. The contents of that document is formed by concatenating all the non-blank text fields
                    (with a space bewteen them). These documents are then indexed by Lucene. Each create, update or delete call updates the set of
                    available "documents". The indices are updated periodically - so new entries will not be immediately visible. The freshness of the
                    data is determined by the ICAT configuration and may be adjusted. As with the other search call you will only see the data you are
                    allowed to see by the authorization rules. Please see the following examples.
                </p>
                <code>List&lt;Object&gt; results = icat.searchText(sessionId, "king", 50, null);</code>
                <p>This obtains the 50 "best" documents with the work "king" in them.</p>

                <code>List&lt;Object&gt; results = icat.searchText(sessionId, "king queen", 50, null);</code>
                <p>returns documents with "king" or "queen" in them.</p>

                <code>List&lt;Object&gt; results = icat.searchText(sessionId, "king AND (queen OR harp", 50, null);</code>
                <p>returns documents with "king" and either "queen" or "harp".</p>

                <p>Case is ignored and there is no need to put in words with different endings but the same stem as common suffices are removed both
                    when storing the document indices and when looking them up. Wild cards may be used - the ? for a single character and * for zero
                    or
                    more. The last argument my be the simple name of an entity as shown below.
                </p>

                <code>List&lt;Object&gt; results = icat.searchText(sessionId, "king", 50, "Investigation");</code>
                <p>This restricts the search to the "Investigation" set of entities.</p>

            </subsection>

        </section>

        <section name="Testing calls">

            <p>There a number of calls to test whether or not a call will be succesful. These can be used in a GUI which is making ICAT calls to avoid
                offering users options that will fail. They have names testCreate, testUpdate and testDelete and have just the same calling sequence
                as the corresponding create, update and delete calls but return void. In each case they do nothing except that if the corresponding
                call would throw an exception then this does too.
            </p>

        </section>

        <section name="Authorization">
            <p>The mechanism is rule based. Rules allow groups of
                users to do things. There are four things that can be
                done: Create, Read, Update and
                Delete. It makes use of
                four tables: Rule, User, Group and UserGroup. The
                authentication mechanism authenticates a person with a
                certain
                name and this name identifies the User in the
                ICAT User table. Groups have names and the UserGroup
                performs the function of a "many to
                many" relationship
                between Users and Groups. Rules are applied to Groups.
                There are special "root users" able to manipulate these
                four
                tables, but only these four unless a "root user" creates
                rules to give himself further powers. Apart from the
                special role of "root
                users" these tables
                behave as other
                ICAT tables do. The set of "root users" is a configuration parameter of the ICAT installation.
            </p>
            <subsection name="Rules" id="rules">
                <p>
                    By default access is denied to all objects, rules allow access. It is only necessary to be permitted by one rule
                    where that rule is
                    only applied to the object referenced directly in the API call. The Rule table has two exposed fields:
                    <tt>crudFlags</tt>
                    and
                    <tt>what</tt>
                    .

                    The field
                    <tt>crudFlags</tt>
                    contains letters from the set "CRUD" to indicate which types of operation are being allowed (Create, Read, Update and/or Delete).
                    The other field,
                    <tt>what</tt>
                    , is the rule itself. There is also a "many to one" relationship to Group which may be absent.
                </p>
                <p>Consider:</p>
                <code>
                    Rule rule = new Rule();
                    <br />
                    rule.setGroup(userOffice);
                    <br />
                    rule.setCrudFlags("CRUD");
                    <br />
                    rule.setWhat("Investigation");
                    <br />
                    icat.create(sessionId, rule);
                </code>
                <p>allows members of the userOffice group full access to all Investigations. Note that the id field of the rule on the client side
                    is
                    not set on the assumption that the client side copy of the rule will not be needed further.
                </p>
                <code>
                    Rule rule = new Rule();
                    <br />
                    rule.setGroup(null); // Not necessary as it will be null on a newly created rule
                    <br />
                    rule.setCrudFlags("R");
                    <br />
                    rule.setWhat("ParameterType");
                    <br />
                    icat.create(sessionId, rule);
                </code>
                <p>allows any authenticated user (with a sessionId) to read Parameters. Consider a group of users: fredReaders.
                    To allow fredReaders to
                    read a datafile with a name of "fred" we could have:
                </p>
                <code>
                    Rule rule = new Rule();
                    <br />
                    rule.setGroup(fredReaders);
                    <br />
                    rule.setCrudFlags("R");
                    <br />
                    rule.setWhat("Datafile [name='fred']");
                    <br />
                    icat.create(sessionId, rule);
                </code>
                <p>More complex restrictions can be added using other related objects. For example to allow read access to Datasets belonging to an
                    Investigation which includes an InvestigationUser which has a user with a name matching the currently authenticated user (from the
                    sessionId) we can have:
                </p>
                <code>
                    Rule rule = new Rule();
                    <br />
                    rule.setGroup(null);
                    <br />
                    rule.setCrudFlags("R");
                    <br />
                    rule.setWhat("Dataset &lt;-&gt; Investigation &lt;-&gt; InvestigationUser [user.name = :user]");
                    <br />
                    icat.create(sessionId, rule);
                </code>
                <p>
                    where the
                    <tt>:user</tt>
                    denotes the currently authenticated user (derived from the
                    sessionId). You will note that the syntax is very similar to that
                    used by
                    the search.
                </p>
            </subsection>
        </section>

        <section name="Notifications">
            <p>
                ICAT is able to send JMS messages. To do this, the table "NotificationRequest" should be populated as needed. This table includes two
                columns:
                <tt>crudFlags</tt>
                and
                <tt>what</tt>
                which are treated in a similar way to columns of the same name in the
                <a href="#rules">authorization rules</a>
                to choose the conditions for sending a message. However if the
                <tt>what</tt>
                field is more than just the name of the entity the request will not be honoured for search calls. The
                <tt>name</tt>
                field identifies the NotificationRequest and must be unique. The
                <tt>datatypes</tt>
                field determines what to include in the message. Possible entries in the space separated list are:
            </p>
            <dl>
                <dt>notificationName</dt>
                <dd>
                    the name as provided in the
                    <tt>name</tt>
                    field of the request.
                </dd>
                <dt>userId</dt>
                <dd>the name of the authenticated user performing the operation resulting in this notification.</dd>

                <dt>entityName</dt>
                <dd>the name of the main entity being referenced. This excludes any INCLUDE fields from a search or get call and also excludes
                    entities besides the top one for create calls.
                </dd>
                <dt>entityId</dt>
                <dd>
                    the id (primary key) of the main entity.
                </dd>
                <dt>query</dt>
                <dd>the query string for a search call.</dd>
            </dl>
            <p>The final field is the destType which must be either DestType.PUBSUB or DestType.P_2_P. The first case publishes the message as a JMS
                topic where it may be read by multiple consumers and the second puts it onto a queue where it will be consumed by the first consumer
                to take it.
            </p>

            <p>
                For example:
            </p>
            <code>
                NotificationRequest notificationRequest = new NotificationRequest();
                <br />
                notificationRequest.setDatatypes("notificationName userId entityName entityId");
                <br />
                notificationRequest.setCrudFlags("C");
                <br />
                notificationRequest.setDestType(DestType.PUBSUB); // Publish/Subscribe
                <br />
                notificationRequest.setWhat("Datafile");
                <br />
                notificationRequest.setName("Test");
                <br />
                icat.create(sessionId, notificationRequest);
            </code>
            <p>
                will send a notification message containing the name of the notification ("Test" in this case"), the userId, the entityName (which
                will
                always be "Datafile" in this case) and its id for every call where a Datafile is created. "Publish/Subscribe" mode will be used
                rather
                than "Point-to-Point". Note that the id field of the notificationRequest on the client side
                is not set on the assumption that the
                client side copy of the notificationRequest will not be needed further. To
                see who is reading which datasets (with
                <tt>get</tt>
                calls) belonging to some
                investigation called "Fred" one could have:
            </p>
            <code>
                NotificationRequest notificationRequest = new NotificationRequest();
                <br />
                notificationRequest.setDatatypes("userId entityId");
                <br />
                notificationRequest.setCrudFlags("R");
                <br />
                notificationRequest.setDestType(DestType.PUBSUB);
                <br />
                notificationRequest.setWhat("Dataset &lt;-&gt; Investigation [name = "Fred"]");
                <br />
                notificationRequest.setName("Fred readers");
                <br />
                icat.create(sessionId, notificationRequest);
            </code>


            <p>Though the notification mechanism is powerful, it does allow information to be published from ICAT which is not protected by the
                normal
                ICAT authorization mechanism. Please publish only the information required to meet your needs and take care that the
                authorization for
                the
                NotificationRequest table is well controlled.
            </p>



            <p>
                Each
                <tt>create</tt>
                ,
                <tt>get</tt>
                ,
                <tt>update</tt>
                and
                <tt>delete</tt>
                call will result in one message for each matching request if the operation is succesful. The
                <tt>createMany</tt>
                and
                <tt>deleteMany</tt>
                calls produce one notification message for each matching NotificationRequest, for each entity, if the operation is succesful. The
                <tt>search</tt>
                operation produces one message per notification request if the operation is succesful. The message will contain the query string
                if
                this was requested. The
                <tt>what</tt>
                field in the NotificationRequest must be just the entity name other the notification will not match.
            </p>
            <p>
                The message is sent as an ObjectMessage - but without an Object being attached. All the information is sent as properties with the
                same name as requested in the
                <tt>dataTypes</tt>
                .
            </p>

        </section>

        <section name="Information">
            <p class="call">String getApiVersion()</p>

            <p>returns the version of the API - this should match the
                version of the client as it is held in Maven for a
                released component. In the case
                of a release candidate
                such as 4.2.0-rc03 the version returned will still be
                4.2.0 .
            </p>

            <p class="call"> EntityInfo getEntityInfo(String beanName)</p>


            <p>returns full information about a table given its name. For example:</p>
            <code>
                EntityInfo ei = icat.getEntityInfo("Investigation");
                <br />
                System.out.println(ei.getClassComment());
                <br />
                for (Constraint c : ei.getConstraints()) {
                <br />
                &#160;&#160;&#160;System.out.println("Constraint columns: " + c.getFieldNames());
                <br />
                }
                <br />
                for (EntityField f : ei.getFields()) {
                <br />
                &#160;&#160;&#160;System.out.println("Field names: " + f.getName());
                <br />
                }
                <br />
            </code>
            <p>
                Prints out some information about the Investigation table. For a list of all available fields in EntityInfo and the objects it
                references please
                consult the
                <a href="apidocs/org/icatproject/EntityInfo.html">javadoc for EntityInfo</a>
                .
            </p>


        </section>
    </body>

</document>
